import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';

export function activate(context: vscode.ExtensionContext) {
    const diagnosticCollection = vscode.languages.createDiagnosticCollection('firestore-rules');

    // 1. COMMAND: Generate/Update Rules (From Part 1)
    let generateCommand = vscode.commands.registerCommand('firestore-rules-helper.generateRules', async () => {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders) return;
        const rootPath = workspaceFolders[0].uri.fsPath;
        const rulesPath = path.join(rootPath, 'firestore.rules');

        const collections = await scanCodebaseForCollections(rootPath);
        if (collections.size === 0) {
            vscode.window.showWarningMessage('FireRule Guard: No collections found.');
            return;
        }

        if (fs.existsSync(rulesPath)) {
            updateExistingRules(rulesPath, collections);
        } else {
            createNewRulesFile(rulesPath, collections);
        }
    });

    // 2. LIVE LINTER: Check for insecure rules as the user types
    if (vscode.window.activeTextEditor) {
        updateDiagnostics(vscode.window.activeTextEditor.document, diagnosticCollection);
    }

    context.subscriptions.push(
        vscode.workspace.onDidChangeTextDocument(e => updateDiagnostics(e.document, diagnosticCollection)),
        vscode.workspace.onDidOpenTextDocument(doc => updateDiagnostics(doc, diagnosticCollection)),
        generateCommand,
        // 3. QUICK FIX: Register the lightbulb provider
        vscode.languages.registerCodeActionsProvider('firestore-rules', new SecurityFixer(), {
            providedCodeActionKinds: [vscode.CodeActionKind.QuickFix]
        })
    );
}

// --- LINTER LOGIC ---
function updateDiagnostics(document: vscode.TextDocument, collection: vscode.DiagnosticCollection): void {
    if (!document.fileName.endsWith('firestore.rules')) return;

    const diagnostics: vscode.Diagnostic[] = [];
    const text = document.getText();

    // Look for common insecure patterns
    const patterns = [
        { regex: /allow\s+read,\s*write:\s*if\s+true;/g, message: "âš ï¸ CRITICAL: Database is open to the world!", severity: vscode.DiagnosticSeverity.Error },
        { regex: /allow\s+write:\s*if\s+request\.auth\s*!=\s*null;/g, message: "ðŸ”’ Suggestion: Restrict write access to resource owners only.", severity: vscode.DiagnosticSeverity.Warning }
    ];

    patterns.forEach(p => {
        let match;
        while ((match = p.regex.exec(text)) !== null) {
            const range = new vscode.Range(
                document.positionAt(match.index),
                document.positionAt(match.index + match[0].length)
            );
            diagnostics.push(new vscode.Diagnostic(range, p.message, p.severity));
        }
    });

    collection.set(document.uri, diagnostics);
}

// --- QUICK FIX LOGIC ---
export class SecurityFixer implements vscode.CodeActionProvider {
    public provideCodeActions(document: vscode.TextDocument, range: vscode.Range | vscode.Selection): vscode.CodeAction[] {
        const line = document.lineAt(range.start.line).text;
        const actions: vscode.CodeAction[] = [];

        if (line.includes('if true;')) {
            const fix = new vscode.CodeAction('ðŸ”’ Secure rule (Require Authentication)', vscode.CodeActionKind.QuickFix);
            fix.edit = new vscode.WorkspaceEdit();
            fix.edit.replace(document.uri, range, "allow read, write: if request.auth != null;");
            actions.push(fix);

            const lock = new vscode.CodeAction('ðŸš« Lock rule (Disable access)', vscode.CodeActionKind.QuickFix);
            lock.edit = new vscode.WorkspaceEdit();
            lock.edit.replace(document.uri, range, "allow read, write: if false;");
            actions.push(lock);
        }

        return actions;
    }
}

// --- SCANNING & GENERATION HELPERS (From Part 1) ---
async function scanCodebaseForCollections(rootPath: string): Promise<Set<string>> {
    const collections = new Set<string>();
    const files = await vscode.workspace.findFiles('**/*.{js,ts,jsx,tsx}', '**/node_modules/**');
    for (const file of files) {
        const document = await vscode.workspace.openTextDocument(file);
        const text = document.getText();
        const regex = /\.collection\(['"]([a-zA-Z0-9_]+)['"]\)/g;
        let match;
        while ((match = regex.exec(text)) !== null) { collections.add(match[1]); }
    }
    return collections;
}

function createNewRulesFile(path: string, collections: Set<string>) {
    let content = `rules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n`;
    collections.forEach(col => {
        content += `\n    match /${col}/{document} {\n      allow read, write: if false; // Generated by FireRule Guard\n    }`;
    });
    content += `\n  }\n}`;
    fs.writeFileSync(path, content);
}

function updateExistingRules(path: string, foundCollections: Set<string>) {
    let currentContent = fs.readFileSync(path, 'utf8');
    const lastBraceIndex = currentContent.lastIndexOf('}');
    let insertionContent = "";
    foundCollections.forEach(col => {
        if (!currentContent.includes(`match /${col}`)) {
            insertionContent += `\n    match /${col}/{document} {\n      allow read, write: if false; // Generated by FireRule Guard\n    }`;
        }
    });
    if (insertionContent) {
        const newContent = currentContent.slice(0, lastBraceIndex) + insertionContent + "\n" + currentContent.slice(lastBraceIndex);
        fs.writeFileSync(path, newContent);
    }
}